--[[
- Trim:... do
    --local t = { ... }
    local t = arg
    if #t > 1 then
        return [[String alloc] init:[StringHelper TrimChars:... string:self.string]]
    else
        return [[String alloc] init:[StringHelper Trim:self.string]]
    end
end
]]    
    
    Capitalize = function(s)
        return s:sub(1, 1):upper() .. s:sub(2)
    end,

    CountOf = function(str, find)
        if not str or not find then
            return 0
        end
        local count, pos, length = 0, 1, find:len()
        while true do
            local p2 = _.string.indexOf(str, find, pos)
            if p2 == -1 then
                break
            end
            count = count + 1
            pos = pos + length
        end

        return count
    end,

    SwapCase = function(s)
        local s2 = ""
        for i = 1, s:len() do
            local char = s:sub(i, i)
            s2 = s2 .. (char:upper() == char and char:lower() or char:upper())
        end
        return s2
    end,

    Join = function(...)
        return table.concat({ ... }, "")
    end,

    SplitLines = function(s)
        local t = System.StringHelper.Split(s, System.Environment.NewLine)
        for i = 1, #t do
            t[i] = System.StringHelper.TrimChars(t[i], "\r")
        end
        return t
    end,

    Split = function(s, ...)
        --local splitters = { ... }
        local _tmp = ...
        local splitters = { _tmp }
        if #splitters > 0 and type(splitters[1]) == "table" then
            splitters = splitters[1]
        end
        local t = { }
        local pos = 1
        local leading = ""
        local first = true
        while pos <= s:len() do
            local flag = false
            for k, splitter in pairs(splitters) do
                --if s:sub(pos, pos + splitter:len() - 1) == splitter then
                local found = System.StringHelper.IndexOf(s, splitter, pos)
                if found ~= -1 and found == pos then
                    local nextIndex = System.StringHelper.IndexOf(s, splitter, pos + splitter:len())
                    if nextIndex == -1 then nextIndex = s:len() + 1 end
                    --if nextIndex == 1 then nextIndex = 2 end
                    table.insert(t, s:sub(pos, nextIndex - 1))
                    if first then
                        t[#t] = leading .. t[#t]
                        first = false
                    end
                    pos = pos + splitter:len()
                    flag = true
                    break
                end
            end
            if not flag then
                if first then
                    leading = leading .. s:sub(pos, pos)
                end
                pos = pos + 1
            end
        end
        return t
    end,

LastIndexOfAny = function(str, chars)
        local index = -1
        for k, v in pairs(chars) do
            local i = System.String.LastIndexOf(str, v)
            if i > index or index == -1 then
                index = i
            end
        end
        return index
    end,

    Replace = function(
    end,
    
    GetTextBetween = function(s, d1, d2, start, end_)
        start = start or 1
        end_ = end_ or s:len()
        local a = System.StringHelper.IndexOf(s, d1, start)
        local b = System.StringHelper.IndexOf(s, d2, a == -1 and start or (a + d1:len()))
        if a ~= -1 and b ~= -1 then
            if a <= end_ and b <= end_ then
                return s:sub(a + d1:len(), b - 1)
            end
        end
        return "" -- In accordance with the Never Throw An Error Theory =P... TODO: Throw an error/return nil ?
    end,
}

setmetatable(System.StringHelper, { __index = System.__index })
